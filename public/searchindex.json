[{"section":"Blog","slug":"susilodev.com/blog/instantly-gain-your-users-trust-with-password-breach-detection-in-signup-forms/","title":"Instantly Gain Your Users&#39; Trust with Password Breach Detection in Signup Forms","description":"adding extra feature at signup forms validation with Password Leak Detection","date":"February 1, 2025","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"susilodev.com/images/password-branch/security-pawned_hu_cedf35d91653bcc0.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"219\"\n          onerror=\"this.onerror='null';this.src='susilodev.com\\/images\\/password-branch\\/security-pawned_hu_39b50a99b0dadfed.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"susilodev.com/images/password-branch/security-pawned_hu_1f804eb78bb054a4.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='susilodev.com\\/images\\/password-branch\\/security-pawned_hu_eb1f33e069242482.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"","tags":"security, reactjs, go, haveibeenpwned","content":" This is a \u0026ldquo;casual\u0026rdquo; article that talks about how data breaches can be used as opportunities, based on how various tech industries are already making use of them. An in-depth technical guide on implementing a password breach checker for web applications using ReactJS and Go. Introduction At present, not all users in the digital era \u0026ldquo;realize the risks\u0026rdquo; of data breaches. This is understandable, as not everyone pays attention to cybersecurity—even software engineers.\nBut when it comes to passwords, it’s a completely different story. It doesn’t matter if someone is tech-savvy or not—passwords will always be a special concern for users. Even if they’re used to logging in with Gmail, they\u0026rsquo;d still freak out if their password got leaked. Why? Because passwords are deeply personal.\nFor example, even if you don\u0026rsquo;t use personal thing for your passwords (which is good), you\u0026rsquo;ll still tend to pick something memorable— whether it\u0026rsquo;s a special character, a favorite anime character, or a combination that you hope will keep playing in your mind for years, maybe even for life.\nThe Hidden Role of Data Breaches in Password Checks Data breaches have been happening for over a decade, affecting major companies like Adobe, Twitter, Facebook, Gmail, Canva, Tokopedia, and more. [source] While web security becomes more complicated, some developers take advantage of data breaches and use them for extra features as a warning \u0026ldquo;the user data has been exposed\u0026rdquo;. It is advised not to reuse it for security reasons.\nhaveibeenpwned (HIBP) As far as I know, the only publicly accessible source for data breaches is HaveIBeenPwned (CMIIW). In fact, almost all paid security services are integrated with it. HaveIBeenPwned allows to search across multiple data breaches from various domains. It was created by Troy Hunt, a cybersecurity expert who also serves as a Microsoft Regional Director. To date, more than 1 billion breached passwords have been collected and integrated into services like 1Password, Mozilla, GitHub, and many others,\nI believe that password breach checking has the potential to make a deeply positive impact on users personally. It can positively influence user behavior, enhance the user experience, and address psychological concerns.\nSome people may be triggered when they realize their password has been exposed, especially if they\u0026rsquo;ve been using it for years. When your platform advises and forces them to change their password because it’s compromised and unsafe, if you make a positive impression at that moment, they will certainly feel greatly assisted and may even update their password on other platforms. And that means, it’s not just the new password they will remember, but also your product. and That’s it. That is the expected behavior.\nInfo\nthis is just my personal opinion, and I don’t have many sources to back it up.\nPragmatic Analysis In another case, if you\u0026rsquo;re familiar with Hostinger.com (a cloud hosting provider), you\u0026rsquo;ll notice that there\u0026rsquo;s no data breach checking during signup on that domain. However, if you buy the product from Hostinger Indonesia (hostinger.co.id), you\u0026rsquo;ll find that password breach checking is applied. It’s interesting to see this difference: while both domains belong to the same company, but Indonesian domain offers an additional feature.\nIn my opinion, Hostinger has really played its role well in Indonesia. If you\u0026rsquo;re truly aware of the situation in Indonesia, you\u0026rsquo;d know that over the past 3 years, many incidents related to cybersecurity and data breaches have occurred.\nindonesian data breach by statistica The chart above shows data from 2021 to 2023, and Indonesia has seen a significant rise in data breaches [source], To make matters worse, the Indonesian government has faced serious data breach issues since July 2024 . [source \u0026amp;] [hot news] The logical consequence of this chart is that data breaches in Q2 2024 should show a noticeable increase, making this case even more relevant and offering an opportunity to take advantage of the situation.\nInfo\nagain, this is my personal opinion, and I don’t have many sources to back it up.\nTechnical Implementation We will use HIBP as a dataset library, and so far, we can do it in two ways:\nUsing the HIBP API. It\u0026rsquo;s free to use, but has a rate limit. or Self-hosting HIBP, we need to download the password breach list and host it on our server. For privacy reasons, HIBP uses K-Anatomy. this means that the password is not sent to the server in plain text. we need to hash the password before sending it to the server. The password is hashed using the SHA-1 algorithm.\nIn general, the flow is roughly like this.\nsequenceDiagram autonumber box rgb(248, 255, 240) Frontend actor User participant Frontend end box rgb(245, 251, 255) Backend participant HIBP_API participant HIBP_Database end User-\u003e\u003eFrontend: Enter plain text Password Note right of User: sukses100% Frontend-\u003e\u003eFrontend: Hash Password (SHA-1) Note right of Frontend: 7a58a286641ec6 Frontend-\u003e\u003eHIBP_API: Send First 5 Characters of Hash (Prefix) Note right of Frontend: 7a58a HIBP_API-\u003e\u003eHIBP_Database: Query Prefix HIBP_Database--\u003e\u003eHIBP_API: Return list of Matching Hashes Note left of HIBP_Database: 7a58a286641ec6:2 Note left of HIBP_Database: 7a58aa8664112d:1 Note left of HIBP_Database: 7a58ab86641ec1:7 HIBP_API--\u003e\u003eFrontend: Respond with Matches as suffix list Note left of HIBP_API: 286641ec6:2 Note left of HIBP_API: a8664112d:1 Note left of HIBP_API: b86641ec1:7 Frontend-\u003e\u003eFrontend: Compare Full Hash Locally Frontend--\u003e\u003eUser: Notify if Compromised The password is sukses100% as a plaintext, and\nFrontend is hashed into a SHA-1 hash like:\n7a58a286641ec6 The first 5 characters of the hash (called the prefix) are extracted as 7a58a. this prefix is sent to the HIBP API to query for possible matches.\nThe HIBP API server sends a prefix query to the HIBP database to find matching hashes.\nIf a match is found, the HIBP database returns a all hash list of matching hashes with pawned counts info. pawned count is The numbers after each hash, represent the number of times that password was seen in breaches. example response:\n7a58a286641ec6:2 7a58aa8664112d:1 7a58ab86641ec1:7 7a58aj86641ec1:5 7a58ag86641ab3:10 7a58al86641123:14 The server receives the matching hashes and filters them to send only the hash suffixes to the frontend, ensuring privacy. example response: 286641ec6:2 a8664112d:1 b86641ec1:7 j86641ec1:5 g86641ab3:10 l86641123:14 The client receives the list of possible matches and compares the suffix hash of the user\u0026rsquo;s password to the list of returned suffix hashes. If a match is found, the user is alerted that their password is compromised and should be changed. Frontend Implementation (Reactjs) sequenceDiagram box rgb(248, 255, 240) Frontend actor User participant Frontend as Nextjs/Remix end participant HIBP_API User-\u003e\u003eFrontend: Enter plain text Password Note right of User: sukses100% Frontend-\u003e\u003eFrontend: Hash Password (SHA-1) Note right of Frontend: 7a58a286641ec6... Frontend-\u003e\u003eHIBP_API: Send First 5 Characters of Hash (Prefix) Note right of Frontend: 7a58a HIBP_API--\u003e\u003eFrontend: Respond with Matches Note left of HIBP_API: 286641ec6:2 Note left of HIBP_API: 286641121:1 Note left of HIBP_API: 286641129:7 Frontend-\u003e\u003eFrontend: Compare Full Hash Locally Frontend--\u003e\u003eUser: Notify if Compromised To hash, send, and compare, basically we’ll be using some simple logic in TypeScript like this.\nimport sha1 from \u0026#34;sha1\u0026#34;; /** * Checks if a password is safe using the HIBP API. * @param password The password to check. * @returns Promise\u0026lt;boolean\u0026gt; - `true` if the password is safe, `false` if it is compromised. */ export async function isPasswordSafety(password: string): Promise\u0026lt;boolean\u0026gt; { try { // Step 1: Hash the password using SHA1 const hashedPassword = sha1(password); const prefix = hashedPassword.substring(0, 5); // First 5 characters of the hash const suffix = hashedPassword.substring(5); // Remaining characters of the hash // Step 2: Fetch data from HIBP API for the hash prefix const response = await fetch(`https://api.pwnedpasswords.com/range/${prefix}`); // Step 3: Check if the response is successful if (!response.ok) { throw new Error(`Failed to fetch: ${response.status} - ${response.statusText}`); } // Step 4: Extract the list of hashes and pawned counts const data = await response.text(); const hashes = data.split(\u0026#34;\\n\u0026#34;); // Split response into individual hash entries // Step 5: Find the hash suffix in the returned list const foundEntry = hashes.find((hash) =\u0026gt; { const [hashSuffix] = hash.split(\u0026#34;:\u0026#34;); // Extract the hash suffix return hashSuffix.toLowerCase() === suffix.toLowerCase(); // Compare suffixes (case-insensitive) }); // Step 6: Return true if no entry is found, otherwise false return foundEntry === undefined; // Safe if no match is found } catch (error) { console.error(\u0026#34;Error checking password:\u0026#34;, error); // Treat any error as a signal that the password might not be safe return false; } } we can use this hook in our component\n// SignUpForm.tsx import { useForm } from \u0026#34;react-hook-form\u0026#34;; import PasswordShowBtn from \u0026#34;./components/PasswordShowBtn\u0026#34;; import { password_validation } from \u0026#34;./schema/password_validation\u0026#34;; import { usePasswordSafety } from \u0026#34;./hooks/usePasswordSafety\u0026#34;; interface IFormInput { password: string; } function App() { const [showPassword, setShowPassword] = useState(false); const { status, error, isLoading, numberOfPawned, isPasswordSafety } = usePasswordSafety(); const { register, handleSubmit, formState: { errors }, } = useForm\u0026lt;IFormInput\u0026gt;({ defaultValues: { password: \u0026#34;\u0026#34;, }, }); const togglePasswordVisibility = () =\u0026gt; { setShowPassword((prev) =\u0026gt; !prev); }; const onSubmit = async (data: IFormInput) =\u0026gt; { // When the form is submitted, check the password with the API await isPasswordSafety(data.password); }; return ( \u0026lt;form onSubmit={handleSubmit(onSubmit)}\u0026gt; \u0026lt;div\u0026gt; \u0026lt;input type={showPassword ? \u0026#34;text\u0026#34; : \u0026#34;password\u0026#34;} // Toggle antara password dan text placeholder=\u0026#34;Password\u0026#34; {...register(\u0026#34;password\u0026#34;, password_validation)} defaultValue=\u0026#34;\u0026#34; /\u0026gt; {errors.password \u0026amp;\u0026amp; \u0026lt;p\u0026gt;{errors.password.message}\u0026lt;/p\u0026gt;} \u0026lt;PasswordShowBtn type=\u0026#34;button\u0026#34; onClick={togglePasswordVisibility}\u0026gt; {showPassword ? \u0026#34;Hide\u0026#34; : \u0026#34;Show\u0026#34;} \u0026lt;/PasswordShowBtn\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button disabled={isLoading} type=\u0026#34;submit\u0026#34;\u0026gt; {isLoading ? \u0026#34;Checking password...\u0026#34; : \u0026#34;Submit\u0026#34;} \u0026lt;/button\u0026gt; {/* Show result or error */} {status === \u0026#34;pawned\u0026#34; \u0026amp;\u0026amp; !isLoading \u0026amp;\u0026amp; ( \u0026lt;p\u0026gt; We found this password in a data leak {numberOfPawned} times. For peace of mind, we recommend choosing a new one. {`${status}`} \u0026lt;/p\u0026gt; )} {status === \u0026#34;safe\u0026#34; \u0026amp;\u0026amp; !isLoading \u0026amp;\u0026amp; ( \u0026lt;div\u0026gt; your password is health\u0026lt;/div\u0026gt; )} {error \u0026amp;\u0026amp; !isLoading \u0026amp;\u0026amp; \u0026lt;p\u0026gt;Error: {error}\u0026lt;/p\u0026gt;} \u0026lt;/form\u0026gt; ); } const rootElement = document.getElementById(\u0026#34;root\u0026#34;); ReactDOM.render(\u0026lt;App /\u0026gt;, rootElement); i also already provide code on codesandbox\nNext up, we’re gonna keep setting up our self-hosted HIBP. For learning purpose, we’ll roll with Go and its standard HTTP library, —it’s simpler, easier to understand, and quicker to set up.\nBackend Implementation (Go with http standar lib) Since Go 1.22.1 was released with a fancy HTTP standard library update, I personally prefer to use that instead of bringing in framework abstractions. Another good news is the performance; it\u0026rsquo;s quite good. You can deep dive into benchmarking Go’s stdlib vs Gin vs Fiber in EKS Kubernetes here. To get the password dataset from Have I Been Pwned, you need a subscription. You can sign up for it here..\nWithout an API key, you won’t be able to download the dataset from HIBP.\nOfficially, we can download it using this tool\nPwnedPasswordsDownloader\nbut if you\u0026rsquo;re not familiar to #C or .net, you can use alternative tools like python, Rust, Nodejs, and PHP . don\u0026rsquo;t worry, the process and flow are pretty much the same across the board. And finally, you\u0026rsquo;ll get a huge .txt file that contains the list of pwned passwords.\nWarning\nBeware! Don’t open the file with regular editors like VSCode or Neovim—it’ll take forever and might freeze your computer. You should use a specialized editor for handling huge files, like less, klogg, or something similar.\nconverting dataset .txt to sqlite Column Name Data Type Constraints prefix TEXT NOT NULL, PRIMARY KEY suffix TEXT NOT NULL, PRIMARY KEY occurrences INTEGER NOT NULL Using OS \u0026ldquo;file reads\u0026rdquo; in Go is still fine, but sometimes we need a more maintainable solution. I prefer converting it to an SQLite database—it’s easier to work with and quite fast. We’ll need a script to transform the .txt file into SQLite.\nimport ( \u0026#34;bufio\u0026#34; \u0026#34;database/sql\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strings\u0026#34; _ \u0026#34;github.com/mattn/go-sqlite3\u0026#34; ) func main() { // Open the text file containing the password hashes and their occurrences. file, err := os.Open(\u0026#34;../data/hibp_example.txt\u0026#34;) defer file.Close() db, err := sql.Open(\u0026#34;sqlite3\u0026#34;, \u0026#34;../data/hbip.db\u0026#34;) defer db.Close() _, err = db.Exec(`CREATE TABLE IF NOT EXISTS pwned_passwords ( prefix TEXT NOT NULL, suffix TEXT NOT NULL, occurrences INTEGER NOT NULL, PRIMARY KEY (prefix, suffix) )`) // Begin a new database transaction to batch insert data for better performance. tx, err := db.Begin() // Prepare an SQL statement to insert or ignore duplicate records into the table. stmt, err := tx.Prepare(\u0026#34;INSERT OR IGNORE INTO pwned_passwords (prefix, suffix, occurrences) VALUES (?, ?, ?)\u0026#34;) defer stmt.Close() // Create a scanner to read the text file line by line. scanner := bufio.NewScanner(file) for scanner.Scan() { line := scanner.Text() parts := strings.Split(line, \u0026#34;:\u0026#34;) // Skip lines that don\u0026#39;t follow the expected format if len(parts) != 2 { continue } hash := parts[0] // The full hash value from the line count := parts[1] // The occurrence count from the line prefix := hash[:5] // Extract the first 5 characters as the prefix suffix := hash[5:] // Extract the remaining characters as the suffix _, err := stmt.Exec(prefix, suffix, count) if err != nil { log.Printf(\u0026#34;Failed to insert record: %v\u0026#34;, err) } } // Commit the transaction to finalize the batch insert into the database. if err := tx.Commit(); err != nil { log.Fatalf(\u0026#34;Failed to commit transaction: %v\u0026#34;, err) } log.Println(\u0026#34;Data conversion completed.\u0026#34;) } You need to run that script to prepare the dataset as an SQLite db.\ngo run scripts/text_to_sqlite.go add a simple router // main.go router := http.NewServeMux() router.HandleFunc(\u0026#34;/api/v1/hibp\u0026#34;, handler.CheckHandler(db)) Maybe we need a separate package to make it reusable. It will contain functions for initializing the database and finding suffixes\npackage database import ( \u0026#34;database/sql\u0026#34; \u0026#34;fmt\u0026#34; _ \u0026#34;github.com/mattn/go-sqlite3\u0026#34; ) type DB struct { *sql.DB } func InitDatabase(dbPath string) (*sql.DB, error) { if dbPath == \u0026#34;\u0026#34; { return nil, fmt.Errorf(\u0026#34;database path is empty\u0026#34;) } db, err := sql.Open(\u0026#34;sqlite3\u0026#34;, dbPath) if err != nil { return nil, fmt.Errorf(\u0026#34;failed to open database: %v\u0026#34;, err) } return db, nil } // finding suffix base on prefix func GetSuffixesByPrefix(db *DB, prefix string) ([]string, error) { query := `SELECT suffix FROM hibp WHERE prefix = ?` rows, err := db.Query(query, prefix) if err != nil { return nil, fmt.Errorf(\u0026#34;failed to query suffixes: %v\u0026#34;, err) } defer rows.Close() var suffixes []string for rows.Next() { var suffix string if err := rows.Scan(\u0026amp;suffix); err != nil { return nil, fmt.Errorf(\u0026#34;failed to scan suffix: %v\u0026#34;, err) } suffixes = append(suffixes, suffix) } if err := rows.Err(); err != nil { return nil, fmt.Errorf(\u0026#34;error iterating over rows: %v\u0026#34;, err) } return suffixes, nil } You can implement the database package in the router handler andBasically, I just made this project more simple and similar like Hono/Express framework.\npackage handler import ( \u0026#34;database/sql\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; ) // query handler func CheckHandler(db *sql.DB) http.HandlerFunc { return func(w http.ResponseWriter, r*http.Request) { if r.Method != http.MethodGet { http.Error(w, \u0026#34;Method not allowed\u0026#34;, http.StatusMethodNotAllowed) return } // fetch prefix from url query prefix := r.URL.Query().Get(\u0026#34;prefix\u0026#34;) if len(prefix) != 5 { http.Error(w, \u0026#34;Prefix must be exactly 5 characters\u0026#34;, http.StatusBadRequest) return } rows, err := db.Query(\u0026#34;SELECT suffix, COUNT(*) FROM pwned_passwords WHERE prefix = ? GROUP BY suffix\u0026#34;, prefix) if err != nil { http.Error(w, \u0026#34;Internal server error\u0026#34;, http.StatusInternalServerError) return } defer rows.Close() var result string for rows.Next() { var suffix string var occurrences int if err := rows.Scan(\u0026amp;suffix, \u0026amp;occurrences); err != nil { http.Error(w, \u0026#34;Error scanning result\u0026#34;, http.StatusInternalServerError) return } // Ensure only the suffix is returned result += fmt.Sprintf(\u0026#34;%s:%d\\n\u0026#34;, suffix, occurrences) } if result == \u0026#34;\u0026#34; { w.WriteHeader(http.StatusNotFound) fmt.Fprint(w, \u0026#34;No suffix found\u0026#34;) return } // returning text format as a response w.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;text/plain\u0026#34;) w.WriteHeader(http.StatusOK) fmt.Fprint(w, result) } } I also providing full source code at github, you can check it out [here]. just make sure Go 1.23 is installed on your machine cz I haven’t finished the Podman/Docker config yet.\nConclusion The budget for this implementation is cheap, even you can do it for free. maybe you\u0026rsquo;ll got rate limits, but it\u0026rsquo;s only affects the client network as a frontend. There is no significant impact on your server, except when you are running a self-hosted HBIP, which might incur some hosting costs.\n"}]